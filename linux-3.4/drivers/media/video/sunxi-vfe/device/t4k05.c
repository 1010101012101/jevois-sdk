/*
 * A V4L2 driver for t4k05 cameras.
 *
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>


#include "camera.h"

MODULE_AUTHOR ("raymonxiu");
MODULE_DESCRIPTION ("A low-level driver for t4k05 sensors");
MODULE_LICENSE ("GPL");

#define DEV_DBG_EN      1
#if(DEV_DBG_EN == 1)
#define vfe_dev_dbg(x,arg...) printk("[t4k05]"x,##arg)
#else
#define vfe_dev_dbg(x,arg...)
#endif
#define vfe_dev_err(x,arg...) printk("[t4k05]"x,##arg)
#define vfe_dev_print(x,arg...) printk("[t4k05]"x,##arg)

#define LOG_ERR_RET(x)  { \
    int ret;  \
    ret = x; \
    if(ret < 0) {\
      vfe_dev_err("error at %s\n",__func__);  \
      return ret; \
    } \
  }

#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_FALLING
#define V4L2_IDENT_SENSOR 0x4005

#define CSI_STBY_ON     0
#define CSI_STBY_OFF    1
#define CSI_RST_ON      0
#define CSI_RST_OFF     1
#define CSI_PWR_ON      1
#define CSI_PWR_OFF     0
#define CSI_AF_PWR_ON   1
#define CSI_AF_PWR_OFF  0
#define regval_list reg_list_a16_d8


#define REG_TERM 0xfffe
#define VAL_TERM 0xfe
#define REG_DLY  0xffff

/*
 * Our nominal (default) frame rate.
 */

#define SENSOR_FRAME_RATE 30


/*
 * The t4k05 sits on i2c with ID 0x6c
 */
#define I2C_ADDR (0x6c)
#define  SENSOR_NAME "t4k05"
static struct v4l2_subdev * glb_sd;

/*
 * Information we maintain about a known sensor.
 */
struct sensor_format_struct;  /* coming later */

struct cfg_array { /* coming later */
  struct regval_list * regs;
  int size;
};

static inline struct sensor_info * to_state (struct v4l2_subdev * sd)
{
  return container_of (sd, struct sensor_info, sd);
}


/*
 * The default register settings
 *
 */


static struct regval_list sensor_default_regs[] = {

  0x0000, 0x14,
  0x0001, 0x61,
  0x0005, 0xFF,
  0x0100, 0x00,
  0x0101, 0x00,
  0x0103, 0x00,
  0x0104, 0x00,
  0x0105, 0x00,
  0x0108, 0x00,
  0x0112, 0x0A,
  0x0113, 0x0A,
  0x0114, 0x03,
  0x0116, 0x00,
  0x0138, 0x01,
  0x013A, 0x32,
  0x0140, 0x00,
  0x0141, 0x00,
  0x0200, 0x07,
  0x0201, 0x6B,
  0x0202, 0x07,
  0x0203, 0x5C,
  0x0204, 0x07,
  0x0205, 0x6B,
  0x0206, 0x02,
  0x0207, 0x24,
  0x0208, 0x00,
  0x0209, 0x86,
  0x020E, 0x01,
  0x020F, 0x00,
  0x0210, 0x01,
  0x0211, 0x68,
  0x0212, 0x01,
  0x0213, 0x60,
  0x0214, 0x00,
  0x0215, 0x00,
  0x0301, 0x08,
  0x0303, 0x00,
  0x0305, 0x00,
  0x0306, 0x00,
  0x0307, 0x21,
  0x0309, 0x08,
  0x030B, 0x00,
  0x0340, 0x07,
  0x0341, 0x5C,
  0x0342, 0x0E,
  0x0343, 0x00,
  0x0344, 0x00,
  0x0345, 0x00,
  0x0346, 0x01,
  0x0347, 0x3C,
  0x0348, 0x0C,
  0x0349, 0xCF,
  0x034A, 0x08,
  0x034B, 0x73,
  0x034C, 0x07,
  0x034D, 0x80,
  0x034E, 0x04,
  0x034F, 0x38,
  0x0350, 0x00,
  0x0381, 0x00,
  0x0382, 0x00,
  0x0383, 0x00,
  0x0401, 0x02,
  0x0403, 0x00,
  0x0405, 0x1B,
  0x0406, 0x00,
  0x0407, 0x10,
  0x0408, 0x00,
  0x0409, 0x28,
  0x040A, 0x00,
  0x040B, 0x18,
  0x040C, 0x0C,
  0x040D, 0xA8,
  0x040E, 0x07,
  0x040F, 0x20,
  0x0601, 0x00,
  0x0602, 0x02,
  0x0603, 0xC0,
  0x0604, 0x02,
  0x0605, 0xC0,
  0x0606, 0x02,
  0x0607, 0xC0,
  0x0608, 0x02,
  0x0609, 0xC0,
  0x060A, 0x00,
  0x060B, 0x00,
  0x060C, 0x00,
  0x060D, 0x00,
  0x060E, 0x00,
  0x060F, 0x00,
  0x0610, 0x00,
  0x0611, 0x00,
  0x0800, 0x80,
  0x0801, 0x28,
  0x0802, 0x68,
  0x0803, 0x48,
  0x0804, 0x40,
  0x0805, 0x28,
  0x0806, 0xF8,
  0x0807, 0x38,
  0x0808, 0x01,
  0x0820, 0x06,
  0x0821, 0x30,
  0x0B05, 0x00,
  0x0B06, 0x01,
  0x2101, 0x00,
  0x2112, 0x0A,
  0x2113, 0x0A,
  0x2114, 0x03,
  0x2116, 0x00,
  0x2200, 0x07,
  0x2201, 0x6B,
  0x2202, 0x00,
  0x2203, 0x10,
  0x2204, 0x07,
  0x2205, 0x6B,
  0x2206, 0x00,
  0x2207, 0x10,
  0x2208, 0x00,
  0x2209, 0x45,
  0x220E, 0x01,
  0x220F, 0x00,
  0x2210, 0x01,
  0x2211, 0x00,
  0x2212, 0x01,
  0x2213, 0x00,
  0x2214, 0x00,
  0x2215, 0x00,
  0x2340, 0x09,
  0x2341, 0xCE,
  0x2342, 0x0E,
  0x2343, 0x74,
  0x2344, 0x00,
  0x2345, 0x00,
  0x2346, 0x00,
  0x2347, 0x00,
  0x2348, 0x0C,
  0x2349, 0xCF,
  0x234A, 0x09,
  0x234B, 0x9F,
  0x234C, 0x0C,
  0x234D, 0xD0,
  0x234E, 0x09,
  0x234F, 0xA0,
  0x2350, 0x00,
  0x2381, 0x00,
  0x2382, 0x00,
  0x2383, 0x00,
  0x2401, 0x00,
  0x2403, 0x00,
  0x2405, 0x10,
  0x2406, 0x00,
  0x2407, 0x10,
  0x2408, 0x00,
  0x2409, 0x00,
  0x240A, 0x00,
  0x240B, 0x00,
  0x240C, 0x0C,
  0x240D, 0xD0,
  0x240E, 0x09,
  0x240F, 0xA0,
  0x2601, 0x00,
  0x2602, 0x02,
  0x2603, 0xC0,
  0x2604, 0x02,
  0x2605, 0xC0,
  0x2606, 0x02,
  0x2607, 0xC0,
  0x2608, 0x02,
  0x2609, 0xC0,
  0x260A, 0x00,
  0x260B, 0x00,
  0x260C, 0x00,
  0x260D, 0x00,
  0x260E, 0x00,
  0x260F, 0x00,
  0x2610, 0x00,
  0x2611, 0x00,
  0x3000, 0x00,
  0x3001, 0x00,
  0x3002, 0xFF,
  0x3003, 0xFF,
  0x3004, 0x00,
  0x3005, 0x78,
  0x3006, 0x00,
  0x3007, 0x00,
  0x3008, 0x40,
  0x3009, 0x20,
  0x300A, 0x0F,
  0x300B, 0x00,
  0x300C, 0x00,
  0x300D, 0x12,
  0x300E, 0x00,
  0x300F, 0x00,
  0x3010, 0x00,
  0x3011, 0x00,
  0x3012, 0x01,
  0x3013, 0xD8,
  0x3014, 0x60,
  0x3015, 0x00,
  0x3016, 0x00,
  0x3017, 0x00,
  0x3018, 0x00,
  0x3019, 0x00,
  0x301A, 0x00,
  0x301B, 0x0F,
  0x301C, 0xFF,
  0x301F, 0x00,
  0x3020, 0x27,
  0x3021, 0x03,
  0x3030, 0x00,
  0x3031, 0x00,
  0x3033, 0x00,
  0x3040, 0x00,
  0x30A0, 0x00,
  0x30A1, 0x00,
  0x30A2, 0xD0,
  0x30A3, 0xF8,
  0x30A4, 0x80,
  0x30A5, 0x01,
  0x30A6, 0x0B,
  0x30A7, 0x00,
  0x30A8, 0x21,
  0x30A9, 0x00,
  0x30AA, 0x88,
  0x30AB, 0x07,
  0x30AC, 0x09,
  0x30AD, 0x60,
  0x30AE, 0x00,
  0x30AF, 0x21,
  0x30B0, 0x00,
  0x30B1, 0x00,
  0x30B2, 0x00,
  0x30B3, 0x79,
  0x30CF, 0x00,
  0x30D0, 0x19,
  0x30D1, 0x25,
  0x30D2, 0x01,
  0x30D3, 0x3B,
  0x3100, 0x07,
  0x3101, 0x00,
  0x3102, 0x00,
  0x3103, 0x00,
  0x3104, 0x06,
  0x3400, 0x00,
  0x3401, 0x00,
  0x3402, 0x00,
  0x3404, 0x00,
  0x3405, 0x00,
  0x3406, 0x00,
  0x3407, 0x00,
  0x3408, 0x00,
  0x3409, 0x00,
  0x340A, 0x00,
  0x340B, 0x00,
  0x340C, 0x00,
  0x340D, 0x00,
  0x340E, 0x00,
  0x340F, 0x00,
  0x3410, 0x00,
  0x3411, 0x00,
  0x3412, 0x00,
  0x3413, 0x00,
  0x3414, 0x00,
  0x3415, 0x00,
  0x3416, 0x00,
  0x3417, 0x00,
  0x3418, 0x00,
  0x3419, 0x00,
  0x341A, 0x00,
  0x341B, 0x00,
  0x341C, 0x00,
  0x341D, 0x00,
  0x341E, 0x00,
  0x341F, 0x00,
  0x3420, 0x00,
  0x3421, 0x00,
  0x3422, 0x00,
  0x3423, 0x00,
  0x3424, 0x00,
  0x3425, 0x00,
  0x3426, 0x00,
  0x3427, 0x00,
  0x3428, 0x00,
  0x3429, 0x00,
  0x342A, 0x00,
  0x342B, 0x00,
  0x342C, 0x00,
  0x342D, 0x00,
  0x342E, 0x00,
  0x342F, 0x00,
  0x3430, 0x00,
  0x3431, 0x00,
  0x3432, 0x00,
  0x3433, 0x00,
  0x3434, 0x00,
  0x3435, 0x00,
  0x3436, 0x00,
  0x3437, 0x00,
  0x3438, 0x00,
  0x3439, 0x00,
  0x343A, 0x00,
  0x343B, 0x00,
  0x343C, 0x00,
  0x343D, 0x00,
  0x343E, 0x00,
  0x343F, 0x00,
  0x3440, 0x00,
  0x3441, 0x00,
  0x3442, 0x00,
  0x3443, 0x00,
  0x3200, 0x10,
  0x3202, 0x04,
  0x3203, 0x04,
  0x3205, 0x00,
  0x3206, 0x04,
  0x3207, 0x00,
  0x3209, 0x00,
  0x320A, 0x00,
  0x320B, 0x51,
  0x320C, 0x00,
  0x320D, 0x20,
  0x320E, 0x00,
  0x320F, 0x08,
  0x3210, 0x00,
  0x3211, 0x20,
  0x3212, 0x00,
  0x3213, 0x40,
  0x3214, 0x13,
  0x3215, 0x10,
  0x3216, 0x00,
  0x3217, 0x00,
  0x3218, 0x05,
  0x321B, 0x80,
  0x321C, 0x00,
  0x321D, 0x00,
  0x321E, 0x00,
  0x321F, 0x00,
  0x3220, 0x00,
  0x3221, 0x00,
  0x3222, 0x26,
  0x3223, 0x04,
  0x3227, 0x10,
  0x3228, 0x28,
  0x3229, 0x0F,
  0x322A, 0x00,
  0x322B, 0x00,
  0x322C, 0x1C,
  0x322D, 0x00,
  0x322E, 0x00,
  0x322F, 0x00,
  0x3230, 0x00,
  0x3231, 0x10,
  0x3232, 0x00,
  0x3233, 0x28,
  0x3234, 0x00,
  0x3235, 0x3B,
  0x3236, 0x00,
  0x3237, 0x00,
  0x3238, 0xE7,
  0x3239, 0x00,
  0x323A, 0x80,
  0x323B, 0x42,
  0x323C, 0x00,
  0x323D, 0x00,
  0x323E, 0x0F,
  0x323F, 0x1F,
  0x3240, 0x00,
  0x3241, 0x00,
  0x3242, 0x10,
  0x3243, 0x00,
  0x3244, 0x80,
  0x3245, 0x80,
  0x3246, 0x80,
  0x3247, 0x80,
  0x3248, 0x00,
  0x3249, 0x07,
  0x324A, 0x00,
  0x324B, 0x00,
  0x324C, 0x00,
  0x324D, 0x00,
  0x324E, 0x00,
  0x3250, 0x03,
  0x3251, 0xFF,
  0x3252, 0xFF,
  0x3253, 0x40,
  0x3254, 0x00,
  0x3255, 0x00,
  0x3256, 0x00,
  0x3257, 0x00,
  0x3258, 0x00,
  0x3259, 0x00,
  0x325A, 0x00,
  0x325B, 0x00,
  0x325C, 0x3F,
  0x325D, 0x1F,
  0x325E, 0x00,
  0x325F, 0x07,
  0x3260, 0x00,
  0x3261, 0x00,
  0x3262, 0x00,
  0x3263, 0x00,
  0x3264, 0x00,
  0x3265, 0x00,
  0x3266, 0x00,
  0x3267, 0x00,
  0x3268, 0x00,
  0x326A, 0x09,
  0x326B, 0xCD,
  0x326C, 0x00,
  0x326D, 0x02,
  0x3270, 0x00,
  0x3271, 0x02,
  0x3272, 0x00,
  0x3273, 0x02,
  0x3276, 0x00,
  0x3277, 0x40,
  0x3278, 0x00,
  0x3279, 0x00,
  0x327A, 0x80,
  0x327C, 0x00,
  0x327D, 0x00,
  0x327E, 0x04,
  0x3280, 0x01,
  0x3281, 0x00,
  0x3282, 0x00,
  0x3284, 0x00,
  0x3285, 0x00,
  0x3286, 0x00,
  0x3287, 0x00,
  0x3288, 0x80,
  0x3289, 0x80,
  0x328A, 0x80,
  0x328B, 0x80,
  0x328C, 0x80,
  0x328D, 0x80,
  0x328E, 0x00,
  0x328F, 0x00,
  0x3290, 0x00,
  0x3291, 0x00,
  0x3292, 0x00,
  0x3293, 0x00,
  0x3294, 0x00,
  0x3295, 0x00,
  0x3296, 0x00,
  0x3297, 0x00,
  0x3298, 0x00,
  0x3299, 0x00,
  0x329A, 0xA0,
  0x329B, 0xB0,
  0x329C, 0x80,
  0x329D, 0xA0,
  0x329E, 0xB0,
  0x329F, 0x80,
  0x32A0, 0xA0,
  0x32A1, 0xB0,
  0x32A2, 0x80,
  0x32A3, 0xA0,
  0x32A4, 0xB0,
  0x32A5, 0x80,
  0x32A6, 0x20,
  0x32A7, 0x20,
  0x32A8, 0x20,
  0x32A9, 0x20,
  0x32AA, 0x20,
  0x32AB, 0x20,
  0x32AC, 0x20,
  0x32AD, 0x20,
  0x32AE, 0x20,
  0x32AF, 0x20,
  0x32B0, 0x20,
  0x32B1, 0x20,
  0x32B2, 0x00,
  0x32B3, 0x00,
  0x32B4, 0x00,
  0x32B5, 0x00,
  0x32B6, 0x00,
  0x32B7, 0x00,
  0x32B8, 0x00,
  0x32B9, 0x00,
  0x32BA, 0x00,
  0x32BB, 0x80,
  0x32BC, 0x01,
  0x32BD, 0x00,
  0x32BE, 0x02,
  0x32BF, 0x0F,
  0x32C0, 0x00,
  0x32C1, 0xFF,
  0x32C2, 0x0C,
  0x32C4, 0x20,
  0x32C5, 0x00,
  0x32C6, 0x68,
  0x32C7, 0x00,
  0x32C8, 0x08,
  0x32C9, 0x00,
  0x32CA, 0x03,
  0x32CB, 0x00,
  0x32CC, 0x80,
  0x32CD, 0x04,
  0x32CE, 0x00,
  0x32CF, 0x00,
  0x32D0, 0x00,
  0x32D1, 0x00,
  0x32D2, 0x00,
  0x32D3, 0x00,
  0x32D4, 0x00,
  0x32D5, 0x88,
  0x32D6, 0x88,
  0x32D7, 0x88,
  0x32D8, 0x88,
  0x32D9, 0x00,
  0x32DA, 0x00,
  0x32DB, 0x00,
  0x32DC, 0x00,
  0x32DD, 0x00,
  0x32DE, 0x00,
  0x32DF, 0x03,
  0x32E0, 0x00,
  0x32E1, 0x00,
  0x32E2, 0x00,
  0x32E3, 0x01,
  0x32E4, 0x00,
  0x32E5, 0x01,
  0x32E6, 0x00,
  0x32E7, 0x20,
  0x32E8, 0x00,
  0x32E9, 0x04,
  0x32EA, 0x00,
  0x32EB, 0x04,
  0x32EC, 0x00,
  0x32ED, 0x04,
  0x32EE, 0x00,
  0x32F0, 0x00,
  0x32F1, 0x00,
  0x32F2, 0x00,
  0x32F3, 0x00,
  0x32F4, 0x00,
  0x32F5, 0x00,
  0x32F6, 0x00,
  0x32F7, 0x00,
  0x32F8, 0x00,
  0x32F9, 0x00,
  0x32FA, 0x00,
  0x32FB, 0x00,
  0x3300, 0x0C,
  0x3301, 0x0B,
  0x3302, 0xB4,
  0x3303, 0x12,
  0x3304, 0x56,
  0x3305, 0x0F,
  0x3306, 0x80,
  0x3307, 0x44,
  0x3308, 0x44,
  0x3309, 0x00,
  0x330A, 0x66,
  0x330B, 0x66,
  0x330C, 0x2C,
  0x330D, 0x0C,
  0x330E, 0x48,
  0x330F, 0xE3,
  0x3310, 0x20,
  0x3311, 0xD5,
  0x3312, 0x24,
  0x3313, 0x05,
  0x3314, 0x00,
  0x3315, 0x07,
  0x3316, 0x00,
  0x3317, 0x03,
  0x3318, 0xD8,
  0x3319, 0x00,
  0x331A, 0x80,
  0x331B, 0x40,
  0x331C, 0x20,
  0x331D, 0x0F,
  0x331E, 0x08,
  0x331F, 0x20,
  0x3320, 0x24,
  0x3321, 0x00,
  0x3322, 0x2C,
  0x3323, 0x00,
  0x3324, 0x03,
  0x3325, 0x07,
  0x3326, 0x8E,
  0x3327, 0x06,
  0x3328, 0x9C,
  0x3329, 0x48,
  0x332A, 0x47,
  0x332B, 0x03,
  0x332C, 0x68,
  0x332D, 0x67,
  0x332E, 0x0A,
  0x332F, 0x40,
  0x3330, 0x04,
  0x3331, 0x10,
  0x3332, 0x00,
  0x3333, 0x67,
  0x3334, 0x00,
  0x3335, 0x0A,
  0x3336, 0x24,
  0x333A, 0x3A,
  0x333B, 0x0A,
  0x333C, 0x46,
  0x333D, 0x24,
  0x333E, 0x3A,
  0x333F, 0x00,
  0x3340, 0x00,
  0x3341, 0x00,
  0x3342, 0x11,
  0x3343, 0x11,
  0x3344, 0x20,
  0x3345, 0x00,
  0x3346, 0x3A,
  0x3347, 0x01,
  0x3348, 0x9C,
  0x3349, 0x31,
  0x334A, 0x00,
  0x334D, 0x1C,
  0x334E, 0x0E,
  0x334F, 0x00,
  0x3351, 0x18,
  0x3352, 0x00,
  0x3353, 0x0C,
  0x3354, 0x30,
  0x3355, 0x30,
  0x3356, 0x00,
  0x3357, 0x00,
  0x3358, 0x00,
  0x3359, 0x00,
  0x335A, 0x00,
  0x335B, 0x00,
  0x335C, 0x00,
  0x335D, 0x23,
  0x335E, 0x18,
  0x335F, 0x0C,
  0x3360, 0x00,
  0x3361, 0x1F,
  0x3362, 0x01,
  0x3363, 0x00,
  0x3364, 0x01,
  0x3365, 0x9C,
  0x3366, 0x03,
  0x3367, 0x33,
  0x3368, 0x03,
  0x3369, 0x10,
  0x336A, 0x14,
  0x336B, 0x01,
  0x336C, 0x80,
  0x336D, 0x00,
  0x336E, 0x97,
  0x336F, 0x03,
  0x3370, 0x3B,
  0x3371, 0x2B,
  0x3372, 0x59,
  0x3373, 0x1D,
  0x3374, 0x3B,
  0x3375, 0x00,
  0x3376, 0xBA,
  0x3377, 0x01,
  0x3378, 0x19,
  0x3379, 0x11,
  0x337A, 0x59,
  0x337B, 0x11,
  0x337C, 0x3B,
  0x337D, 0x59,
  0x337E, 0x6C,
  0x337F, 0x00,
  0x3380, 0xBA,
  0x3381, 0x3B,
  0x3382, 0x01,
  0x3383, 0x19,
  0x3384, 0x0C,
  0x3385, 0x09,
  0x3386, 0x16,
  0x3387, 0x09,
  0x3388, 0x46,
  0x3389, 0x09,
  0x338A, 0x01,
  0x338B, 0x1C,
  0x338C, 0x1A,
  0x338D, 0x00,
  0x338E, 0x87,
  0x338F, 0x1A,
  0x3390, 0x03,
  0x3391, 0x00,
  0x3392, 0x91,
  0x3393, 0x00,
  0x3394, 0x91,
  0x3395, 0x01,
  0x3396, 0xC3,
  0x3397, 0x1A,
  0x3398, 0x03,
  0x3399, 0xE8,
  0x339A, 0x80,
  0x339B, 0xF0,
  0x339D, 0x00,
  0x339E, 0x0B,
  0x339F, 0x0F,
  0x33A0, 0x0B,
  0x33A1, 0x0F,
  0x33A2, 0x0B,
  0x33A3, 0x0B,
  0x33A4, 0x09,
  0x33A5, 0x0F,
  0x33A6, 0x09,
  0x33A7, 0x0F,
  0x33A8, 0x17,
  0x33A9, 0x0B,
  0x33AA, 0x14,
  0x33AB, 0x00,
  0x33AC, 0x28,
  0x33AD, 0x0F,
  0x33AE, 0x00,
  0x33B0, 0x04,
  0x33B1, 0x00,
  0x33B2, 0x40,
  0x33B3, 0x1B,
  0x33B4, 0x00,
  0x33B5, 0x80,
  0x33B6, 0x00,
  0x33B7, 0x3C,
  0x33B8, 0x00,
  0x33B9, 0x1E,
  0x33BA, 0x00,
  0x33BB, 0x3C,
  0x33BC, 0x00,
  0x33BD, 0x1E,
  0x33BE, 0x70,
  0x33BF, 0x00,
  0x33C0, 0x00,
  0x33C1, 0x00,
  0x33C2, 0x00,
  0x33C3, 0x00,
  0x33C4, 0x00,
  0x33C5, 0x78,
  0x33C6, 0x00,
  0x33C8, 0x00,
  0x33C9, 0x80,
  0x33CA, 0x00,
  0x33CB, 0x10,
  0x33CC, 0x00,
  0x33CD, 0x00,
  0x33CE, 0xFF,
  0x33CF, 0x10,
  0x33D0, 0x80,
  0x33D1, 0x60,
  0x33D2, 0x02,
  0x33D3, 0x02,
  0x33D4, 0x06,
  0x33D5, 0x0E,
  0x33D6, 0x31,
  0x33D7, 0x8E,
  0x33D8, 0x10,
  0x33D9, 0xA0,
  0x33DA, 0x20,
  0x33DB, 0xC7,
  0x33DC, 0x00,
  0x33DD, 0x30,
  0x33DE, 0xC4,
  0x33DF, 0xC7,
  0x33E0, 0x00,
  0x33E1, 0x10,
  0x33E2, 0x84,
  0x33E3, 0x5F,
  0x33E4, 0x32,
  0x33E5, 0x11,
  0x33E6, 0x11,
  0x33E7, 0x8E,
  0x33E8, 0x00,
  0x33E9, 0x00,
  0x33EA, 0x00,
  0x33EB, 0x00,
  0x33EC, 0x00,
  0x33ED, 0x00,
  0x33EE, 0x00,
  0x33EF, 0x00,
  0x33F0, 0x00,
  0x33F1, 0x06,
  0x33F2, 0x00,
  0x33F3, 0x37,
  0x33F4, 0x00,
  0x33F5, 0x27,
  0x33F6, 0x00,
  0x33F7, 0x14,
  0x33F8, 0x00,
  0x33F9, 0x38,
  0x33FA, 0x00,
  0x33FC, 0x00,
  0x33FD, 0x00,
  0x33FE, 0x30,
  0x33FF, 0x00,
  0x3600, 0x00,
  0x3601, 0x00,
  0x3602, 0x04,
  0x3603, 0x00,
  0x3604, 0x00,
  0x3605, 0x00,
  0x3606, 0x00,
  0x3607, 0x00,
  0x3608, 0x00,
  0x3609, 0x03,
  0x360A, 0xFF,
  0x360B, 0x00,
  0x360C, 0x00,
  0x360D, 0x00,
  0x360E, 0x00,
  0x360F, 0x00,
  0x3610, 0x0D,
  0x3611, 0x80,
  0x3612, 0x00,
  0x3613, 0x00,
  0x3614, 0x00,
  0x3615, 0x00,
  0x3616, 0x00,
  0x3617, 0x00,
  0x3618, 0x00,
  0x3619, 0x55,
  0x361A, 0x2A,
  0x3500, 0x00,
  0x3501, 0x00,
  0x3502, 0x00,
  0x3503, 0x00,
  0x3504, 0x00,
  0x3505, 0x00,
  0x3506, 0x00,
  0x3507, 0x00,
  0x3508, 0x00,
  0x3509, 0x00,
  0x350A, 0x00,
  0x350B, 0x00,
  0x350C, 0x00,
  0x350D, 0x00,
  0x350E, 0x00,
  0x350F, 0x00,
  0x3510, 0x00,
  0x3511, 0x00,
  0x3512, 0x00,
  0x3513, 0x00,
  0x3514, 0x00,
  0x3515, 0x00,
  0x3516, 0x00,
  0x3517, 0x00,
  0x3518, 0x00,
  0x3519, 0x00,
  0x351A, 0x00,
  0x351B, 0x00,
  0x351C, 0x00,
  0x351D, 0x00,
  0x351E, 0x00,
  0x351F, 0x00,
  0x3520, 0x00,
  0x3521, 0x00,
  0x3522, 0x00,
  0x3523, 0x00,
  0x3524, 0x00,
  0x3525, 0x00,
  0x3526, 0x00,
  0x3527, 0x00,
  0x3528, 0x00,
  0x3529, 0x00,
  0x352A, 0x00,
  0x352B, 0x00,
  0x352C, 0x00,
  0x352D, 0x00,
  0x352E, 0x00,
  0x352F, 0x00,
  0x3530, 0x00,
  0x3531, 0x00,
  0x3532, 0x00,
  0x3533, 0x00,
  0x3534, 0x00,
  0x3535, 0x00,
  0x3536, 0x00,
  0x3537, 0x00,
  0x3538, 0x00,
  0x3539, 0x00,
  0x353A, 0x00,
  0x353B, 0x00,
  0x353C, 0x00,
  0x353D, 0x00,
  0x353E, 0x00,
  0x353F, 0x00,
  0x3540, 0x00,
  0x3541, 0x00,
  0x3542, 0x00,
  0x3543, 0x00,
  0x3544, 0x00,
  0x3545, 0x00,
  0x3546, 0x00,
  0x3547, 0x00,
  0x3548, 0x00,
  0x3549, 0x00,
  0x354A, 0x00,
  0x354B, 0x00,
  0x354C, 0x00,
  0x354D, 0x00,
  0x354E, 0x00,
  0x354F, 0x00,
  0x3550, 0x00,
  0x3551, 0x00,
  0x3552, 0x00,
  0x3553, 0x00,
  0x3554, 0x00,
  0x3555, 0x00,
  0x3556, 0x00,
  0x3557, 0x00,
  0x3558, 0x00,
  0x3559, 0x00,
  0x355A, 0x00,
  0x355B, 0x00,
  0x355C, 0x00,
  0x355D, 0x00,
  0x355E, 0x00,
  0x355F, 0x00,
  0x3560, 0x00,
  0x3561, 0x00,
  0x3562, 0x00,
  0x3563, 0x00,
  0x3564, 0x00,
  0x3565, 0x00,
  0x3566, 0x00,
  0x3567, 0x00,
  0x3568, 0x00,
  0x3569, 0x00,
  0x356A, 0x00,
  0x356B, 0x00,
  0x356C, 0x00,
  0x356D, 0x00,
  0x356E, 0x00,
  0x356F, 0x00,
  0x3570, 0x00,
  0x3571, 0x00,
  0x3572, 0x00,
  0x3573, 0x00,
  0x3574, 0x00,
  0x3575, 0x00,
  0x3576, 0x00,
  0x3577, 0x00,
  0x3578, 0x00,
  0x3579, 0x00,
  0x357A, 0x00,
  0x357B, 0x00,
  0x357C, 0x00,
  0x357D, 0x00,
  0x357E, 0x00,
  0x357F, 0x00,
  0x3580, 0x00,
  0x3581, 0x00,
  0x3582, 0x00,
  0x3583, 0x00,
  0x3584, 0x00,
  0x3585, 0x00,
  0x3586, 0x00,
  0x3587, 0x00,
  0x3588, 0x00,
  0x3589, 0x00,
  0x358A, 0x00,
  0x358B, 0x00,
  0x358C, 0x00,
  0x358D, 0x00,
  0x358E, 0x00,
  0x358F, 0x00,
  0x3590, 0x00,
  0x3591, 0x00,
  0x3592, 0x00,
  0x3593, 0x00,
  0x3594, 0x00,
  0x3595, 0x00,
  0x3596, 0x00,
  0x3597, 0x00,
  0x3598, 0x00,
  0x3599, 0x00,
  0x359A, 0x00,
  0x359B, 0x00,
  0x359C, 0x00,
  0x359D, 0x00,
  0x359E, 0x00,
  0x359F, 0x00,
  0x35A0, 0x00,
  0x35A1, 0x00,
  0x35A2, 0x00,
  0x35A3, 0x00,
  0x35A4, 0x00,
  0x35A5, 0x00,
  0x35A6, 0x00,
  0x35A7, 0x00,
  0x35A8, 0x00,
  0x35A9, 0x00,
  0x35AA, 0x00,
  0x35AB, 0x00,
  0x35AC, 0x00,
  0x35AD, 0x00,
  0x35AE, 0x00,
  0x35AF, 0x00,
  0x35B0, 0x00,
  0x35B1, 0x00,
  0x35B2, 0x00,
  0x35B3, 0x00,
  0x35B4, 0x00,
  0x35B5, 0x00,
  0x35B6, 0x00,
  0x35B7, 0x00,
  0x35B8, 0x00,
  0x35B9, 0x00,
  0x35BA, 0x00,
  0x35BB, 0x00,
  0x35BC, 0x00,
  0x35BD, 0x00,
  0x35BE, 0x00,
  0x35BF, 0x00,
  0x35C0, 0x00,
  0x35C1, 0x00,
  0x35C2, 0x00,
  0x35C3, 0x00,
  0x35C4, 0x00,
  0x35C5, 0x00,
  0x35C6, 0x00,
  0x35C7, 0x00,
  0x35C8, 0x00,
  0x35C9, 0x00,
  0x35CA, 0x00,
  0x35CB, 0x00,
  0x35CC, 0x00,
  0x35CD, 0x00,
  0x35CE, 0x00,
  0x35CF, 0x00,
  0x35D0, 0x00,
  0x35D1, 0x00,
  0x35D2, 0x00,
  0x35D3, 0x00,
  0x35D4, 0x00,
  0x35D5, 0x00,
  0x35D6, 0x00,
  0x35D7, 0x00,
  0x35D8, 0x00,
  0x35D9, 0x00,
  0x35DA, 0x00,
  0x35DB, 0x00,
  0x35DC, 0x00,
  0x35DD, 0x00,
  0x35DE, 0x00,
  0x35DF, 0x00,
  0x35E0, 0x00,
  0x35E1, 0x00,
  0x35E2, 0x00,
  0x35E3, 0x00,
  0x35E4, 0x00,
  0x35E5, 0x00,
  0x35E6, 0x00,
  0x35E7, 0x00,
  0x35E8, 0x00,
  0x35E9, 0x00,
  0x35EA, 0x00,
  0x35EB, 0x00,
  0x35EC, 0x00,
  0x35ED, 0x00,
  0x35EE, 0x00,
  0x35EF, 0x00,
  0x35F0, 0x00,
  0x35F1, 0x00,
  0x35F2, 0x00,
  0x35F3, 0x00,
  0x35F4, 0x00,
  0x35F5, 0x00,
  0x35F6, 0x00,
  0x35F7, 0x00,
  0x35F8, 0x00,
  0x35F9, 0x00,
  0x35FA, 0x00,
  0x35FB, 0x00,
  0x35FC, 0x00,
  0x35FD, 0x00,
  0x35FE, 0x00,
  0x35FF, 0x00,
  0xA700, 0x00,
  0xA701, 0x00,
  0xA702, 0x00,
  0xA703, 0x80,
  0xA704, 0x00,
  0xA705, 0x00,
  0xA707, 0x03,
  0xA709, 0x00,
  0xA70A, 0x00,
  0xA70B, 0x00,
  0xA70C, 0x00,
};

static struct regval_list sensor_8M_regs[] = {
  0x0104, 0x01,
  0x0301, 0x06,
  0x0303, 0x00,
  0x0305, 0x01,
  0x0306, 0x00,
  0x0307, 0x41,
  0x0309, 0x08,
  0x030B, 0x00,
  0x30AC, 0x18,
  0x30AD, 0x00,
  0x30AE, 0x00,
  0x30AF, 0x41,
  0x30B0, 0x01,
  0x0340, 0x09,
  0x0341, 0xce,
  0x0342, 0x0d,
  0x0343, 0x7e,
  0x0346, 0x00,
  0x0347, 0x00,
  0x034A, 0x09,
  0x034B, 0x9f,
  0x034C, 0x0c,
  0x034D, 0xd0,
  0x034E, 0x09,
  0x034F, 0xa0,
  0x0350, 0x00,
  0x0381, 0x00,
  0x0382, 0x00,
  0x0383, 0x00,
  0x0401, 0x02,
  0x0405, 0x10,
  0x0408, 0x00,
  0x0409, 0x64,
  0x040A, 0x00,
  0x040B, 0x64,
  0x040C, 0x0B,
  0x040D, 0xB8,
  0x040E, 0x08,
  0x040F, 0x98,
  0x3030, 0x00,
  0x321C, 0x00,
  0x30A6, 0x0B,
  0x0104, 0x00,
  
  0x0800, 0x80,
  0x0801, 0x10,
  0x0802, 0x80,
  0x0803, 0xF0,
  0x0804, 0xF8,
  0x0805, 0x30,
  0x0806, 0xF8,
  0x0807, 0x38,
  
  0x0808, 0x00,
  0x0820, 0x0c,
  0x0821, 0x30,
  
  0x0112, 0x0C,
  0x0113, 0x0C,
  0x2112, 0x0C,
  0x2113, 0x0C,
  
  0x0114, 0x00 | (4 - 1),
  0x2114, 0x00 | (4 - 1),
  0x3009, 0x20 & (~ (0 << 5) ),
  0x300A, 0x00,
  0x300B, 0x00,
  0x300C, 0x00,
  
  0x0104, 0x00,
  0x0100, 0x00,
  
  0x0100, 0x01,
};

static struct regval_list sensor_1080p_regs[] = {
  0x0100, 0x00,
  
  0x0104, 0x01,
  0x0301, 0x06,
  0x0303, 0x00,
  0x0305, 0x01,
  0x0306, 0x00,
  0x0307, 0x41,
  0x0309, 0x08,
  0x030B, 0x00,
  0x30AC, 0x18,
  0x30AD, 0x00,
  0x30AE, 0x00,
  0x30AF, 0x41,
  0x30B0, 0x01,
  0x0340, 0x09,
  0x0341, 0xce,
  0x0342, 0x0D,
  0x0343, 0x7E,
  0x0346, 0x01,
  0x0347, 0x34,
  0x034A, 0x08,
  0x034B, 0x6e,
  0x034C, 0x07,
  0x034D, 0x90,
  0x034E, 0x04,
  0x034F, 0x48,
  0x0350, 0x00,
  0x0381, 0x00,
  0x0382, 0x00,
  0x0383, 0x00,
  0x0401, 0x02,
  0x0405, 0x1B,
  0x0408, 0x00,
  0x0409, 0x06,
  0x040A, 0x00,
  0x040B, 0x00,
  0x040C, 0x0C,
  0x040D, 0xC4,
  0x040E, 0x07,
  0x040F, 0x3A,
  0x3030, 0x00,
  0x321C, 0x01,
  0x30A6, 0x0B,
  0x0104, 0x00,
  0x0800, 0x80,
  0x0801, 0x18,
  0x0802, 0x80,
  0x0803, 0xF0,
  0x0804, 0xF8,
  0x0805, 0x30,
  0x0806, 0xF8,
  0x0807, 0x38,
  0x0808, 0x00,
  0x0820, 0x0C,
  0x0821, 0x30,
  0x0112, 0x0C,
  0x0113, 0x0C,
  0x0114, 0x03,
  0x2112, 0x0C,
  0x2113, 0x0C,
  0x2114, 0x03,
  0x3009, 0x00,
  0x300A, 0x00,
  0x300B, 0x00,
  0x300C, 0x00,
  0x0104, 0x00,
  
  0x0100, 0x01,
};

static struct regval_list sensor_1080p_crop_regs[] = {
  0x0100, 0x00,
  
  0x0104, 0x01,
  0x0301, 0x06,
  0x0303, 0x00,
  0x0305, 0x01,
  0x0306, 0x00,
  0x0307, 0x41,
  0x0309, 0x08,
  0x030B, 0x00,
  0x30AC, 0x18,
  0x30AD, 0x00,
  0x30AE, 0x00,
  0x30AF, 0x41,
  0x30B0, 0x01,
  0x0340, 0x04,
  0x0341, 0xd3,
  0x0342, 0x0d,
  0x0343, 0xac,
  0x0346, 0x02,
  0x0347, 0xAC,
  0x034A, 0x06,
  0x034B, 0xF4,
  0x034C, 0x07,
  0x034D, 0x90,
  0x034E, 0x04,
  0x034F, 0x48,
  0x0350, 0x00,
  0x0381, 0x00,
  0x0382, 0x00,
  0x0383, 0x00,
  0x0401, 0x00,
  0x0405, 0x10,
  0x0408, 0x01,
  0x0409, 0x44,
  0x040A, 0x00,
  0x040B, 0x00,
  0x040C, 0x07,
  0x040D, 0x90,
  0x040E, 0x04,
  0x040F, 0x48,
  0x3030, 0x03,
  0x321C, 0x01,
  0x30A6, 0x0B,
  0x0104, 0x00,
  0x0800, 0x80,
  0x0801, 0x18,
  0x0802, 0x80,
  0x0803, 0xF0,
  0x0804, 0xF8,
  0x0805, 0x30,
  0x0806, 0xF8,
  0x0807, 0x38,
  0x0808, 0x00,
  0x0820, 0x0C,
  0x0821, 0x30,
  0x0112, 0x0C,
  0x0113, 0x0C,
  0x0114, 0x03,
  0x2112, 0x0C,
  0x2113, 0x0C,
  0x2114, 0x03,
  0x3009, 0x00,
  0x300A, 0x00,
  0x300B, 0x00,
  0x300C, 0x00,
  0x0104, 0x00,
  
  0x0100, 0x01,
};

static struct regval_list sensor_oe_disable_regs[] = {

};

static struct regval_list sensor_oe_enable_regs[] = {

};

/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 *
 */

static struct regval_list sensor_fmt_raw[] = {

};

/*
 * Low-level register I/O.
 *
 */


/*
 * On most platforms, we'd rather do straight i2c I/O.
 */
static int sensor_read (struct v4l2_subdev * sd, unsigned short reg,
                        unsigned char * value)
{
  int ret = 0;
  int cnt = 0;
  
  ret = cci_read_a16_d8 (sd, reg, value);
  while (ret != 0 && cnt < 2)
  {
    ret = cci_read_a16_d8 (sd, reg, value);
    cnt++;
  }
  if (cnt > 0)
  { vfe_dev_dbg ("sensor read retry=%d\n", cnt); }
  
  return ret;
}

static int sensor_write (struct v4l2_subdev * sd, unsigned short reg,
                         unsigned char value)
{
  int ret = 0;
  int cnt = 0;
  
  ret = cci_write_a16_d8 (sd, reg, value);
  while (ret != 0 && cnt < 2)
  {
    ret = cci_write_a16_d8 (sd, reg, value);
    cnt++;
  }
  if (cnt > 0)
  { vfe_dev_dbg ("sensor write retry=%d\n", cnt); }
  
  return ret;
}

/*
 * Write a list of register settings;
 */
static int sensor_write_array (struct v4l2_subdev * sd, struct regval_list * regs, int array_size)
{
  int i = 0;
  
  if (!regs)
  { return 0; }
  
  while (i < array_size)
  {
    if (regs->addr == REG_DLY) {
      msleep (regs->data);
    }
    else {
      LOG_ERR_RET (sensor_write (sd, regs->addr, regs->data) )
    }
    i++;
    regs++;
  }
  return 0;
}

/*
 * Code for dealing with controls.
 * fill with different sensor module
 * different sensor module has different settings here
 * if not support the follow function ,retrun -EINVAL
 */

/* *********************************************begin of ******************************************** */
/*
static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  unsigned char rdval;

  LOG_ERR_RET(sensor_read(sd, 0x3821, &rdval))

  rdval &= (1<<1);
  rdval >>= 1;

  *value = rdval;

  info->hflip = *value;
  return 0;
}

static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);
  unsigned char rdval;

  if(info->hflip == value)
    return 0;

  LOG_ERR_RET(sensor_read(sd, 0x3821, &rdval))

  switch (value) {
    case 0:
      rdval &= 0xf9;
      break;
    case 1:
      rdval |= 0x06;
      break;
    default:
      return -EINVAL;
  }

  LOG_ERR_RET(sensor_write(sd, 0x3821, rdval))

  mdelay(10);
  info->hflip = value;
  return 0;
}

static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
{
  struct sensor_info *info = to_state(sd);
  unsigned char rdval;

  LOG_ERR_RET(sensor_read(sd, 0x3820, &rdval))

  rdval &= (1<<1);
  *value = rdval;
  rdval >>= 1;

  info->vflip = *value;
  return 0;
}

static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
{
  struct sensor_info *info = to_state(sd);
  unsigned char rdval;

  if(info->vflip == value)
    return 0;

  LOG_ERR_RET(sensor_read(sd, 0x3820, &rdval))

  switch (value) {
    case 0:
      rdval &= 0xf9;
      break;
    case 1:
      rdval |= 0x06;
      break;
    default:
      return -EINVAL;
  }

  LOG_ERR_RET(sensor_write(sd, 0x3820, rdval))

  mdelay(10);
  info->vflip = value;
  return 0;
}
*/
static int sensor_g_exp (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  unsigned char explow, exphigh;
  unsigned int exp_tmp;
  
  sensor_read (sd, 0x0202, &exphigh);
  sensor_read (sd, 0x0203, &explow);
  
  exp_tmp = ( (exphigh << 8) + explow) << 4;
  
  info->exp = exp_tmp;
  *value = info->exp;
  vfe_dev_dbg ("sensor_get_exposure = %d\n", info->exp);
  return 0;
}

static int sensor_s_exp (struct v4l2_subdev * sd, unsigned int exp_val)
{
  struct sensor_info * info = to_state (sd);
  unsigned char explow, exphigh;
  unsigned int exp_tmp;
  
  vfe_dev_dbg ("sensor_set_exposure = %d\n", exp_val);
  
  if (exp_val > 0xffffff)
  { exp_val = 0xffff00; }
  
  if (exp_val < 16)
  { exp_val = 16; }
  
  exp_tmp = (exp_val + 8) >> 4;
  
  vfe_dev_dbg ("sensor_set_exposure real= %d\n", exp_tmp);
  
  if (info->exp == exp_tmp)
  { return 0; }
  
  exphigh = (unsigned char) ( (0xff00 & exp_tmp) >> 8);
  explow  = (unsigned char) ( (0x00ff & exp_tmp) );
  
  sensor_write (sd, 0x0202, exphigh);
  sensor_write (sd, 0x0203, explow);
  
  info->exp = exp_tmp;
  return 0;
}

static int sensor_g_gain (struct v4l2_subdev * sd, __s32 * value)
{
  struct sensor_info * info = to_state (sd);
  unsigned char gainlow = 0;
  unsigned char gainhigh = 0;
  unsigned int gain_tmp;
  
  sensor_read (sd, 0x0208, &gainhigh);
  sensor_read (sd, 0x0209, &gainlow);
  
  gain_tmp = ( (gainhigh << 8) + gainlow) << 4;
  
  info->gain = gain_tmp;
  *value = info->gain;
  
  vfe_dev_dbg ("sensor_get_gain = %d\n", info->gain);
  return 0;
}

static int sensor_s_gain (struct v4l2_subdev * sd, int gain_val)
{
  struct sensor_info * info = to_state (sd);
  unsigned char gainlow = 0;
  unsigned char gainhigh = 0;
  unsigned int gain_tmp;
  
  vfe_dev_dbg ("sensor_set_gain = %d\n", gain_val);
  
  if (gain_val < (1 << 4) )
  { gain_val = (1 << 4); }
  
  if (info->gain == gain_val)
  { return 0; }
  
  gain_tmp = ( (gain_val) * 65) >> 4;
  gainlow = (unsigned char) (gain_tmp & 0xff);
  gainhigh = (unsigned char) ( (gain_tmp >> 8) & 0xff);
  
  sensor_write (sd, 0x0208, gainhigh);
  sensor_write (sd, 0x0209, gainlow);
  
  info->gain = gain_val;
  
  return 0;
}

static int sensor_s_sw_stby (struct v4l2_subdev * sd, int on_off)
{
}

/*
 * Stuff that knows about the sensor.
 */

static int sensor_power (struct v4l2_subdev * sd, int on)
{
  int ret;
  
  ret = 0;
  switch (on)
  {
  case CSI_SUBDEV_STBY_ON:
    vfe_dev_dbg ("CSI_SUBDEV_STBY_ON!\n");
    ret = sensor_s_sw_stby (sd, CSI_STBY_ON);
    if (ret < 0)
    { vfe_dev_err ("soft stby falied!\n"); }
    mdelay (10);
    cci_lock (sd);
    vfe_gpio_write (sd, PWDN, CSI_STBY_ON);
    cci_unlock (sd);
    vfe_set_mclk (sd, OFF);
    break;
  case CSI_SUBDEV_STBY_OFF:
    vfe_dev_dbg ("CSI_SUBDEV_STBY_OFF!\n");
    cci_lock (sd);
    vfe_set_mclk_freq (sd, MCLK);
    vfe_set_mclk (sd, ON);
    mdelay (10);
    vfe_gpio_write (sd, PWDN, CSI_STBY_OFF);
    mdelay (10);
    cci_unlock (sd);
    ret = sensor_s_sw_stby (sd, CSI_STBY_OFF);
    if (ret < 0)
    { vfe_dev_err ("soft stby off falied!\n"); }
    mdelay (10);
    break;
  case CSI_SUBDEV_PWR_ON:
    vfe_dev_dbg ("CSI_SUBDEV_PWR_ON!\n");
    cci_lock (sd);
    vfe_gpio_set_status (sd, PWDN, 1);
    vfe_gpio_set_status (sd, RESET, 1);
    vfe_gpio_write (sd, PWDN, CSI_STBY_ON);
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    mdelay (1);
    vfe_set_mclk_freq (sd, MCLK);
    vfe_set_mclk (sd, ON);
    mdelay (10);
    vfe_gpio_write (sd, POWER_EN, CSI_PWR_ON);
    vfe_set_pmu_channel (sd, IOVDD, ON);
    vfe_set_pmu_channel (sd, AVDD, ON);
    vfe_set_pmu_channel (sd, DVDD, ON);
    vfe_set_pmu_channel (sd, AFVDD, ON);
    vfe_gpio_write (sd, PWDN, CSI_STBY_OFF);
    mdelay (10);
    vfe_gpio_write (sd, RESET, CSI_RST_OFF);
    mdelay (30);
    cci_unlock (sd);
    break;
  case CSI_SUBDEV_PWR_OFF:
    vfe_dev_dbg ("CSI_SUBDEV_PWR_OFF!\n");
    cci_lock (sd);
    vfe_set_mclk (sd, OFF);
    vfe_gpio_write (sd, POWER_EN, CSI_PWR_OFF);
    vfe_set_pmu_channel (sd, AFVDD, OFF);
    vfe_set_pmu_channel (sd, DVDD, OFF);
    vfe_set_pmu_channel (sd, AVDD, OFF);
    vfe_set_pmu_channel (sd, IOVDD, OFF);
    mdelay (10);
    vfe_gpio_write (sd, POWER_EN, CSI_STBY_OFF);
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    vfe_gpio_set_status (sd, RESET, 0);
    vfe_gpio_set_status (sd, PWDN, 0);
    cci_unlock (sd);
    break;
  default:
    return -EINVAL;
  }
  
  return 0;
}

static int sensor_reset (struct v4l2_subdev * sd, u32 val)
{
  switch (val)
  {
  case 0:
    vfe_gpio_write (sd, RESET, CSI_RST_OFF);
    mdelay (10);
    break;
  case 1:
    vfe_gpio_write (sd, RESET, CSI_RST_ON);
    mdelay (10);
    break;
  default:
    return -EINVAL;
  }
  
  return 0;
}

static int sensor_detect (struct v4l2_subdev * sd)
{
  unsigned char rdval;
  
  LOG_ERR_RET (sensor_read (sd, 0x0000, &rdval) )
  vfe_dev_dbg ("sensor read id=0x%x\n", rdval);
  if (rdval != 0x14)
  { return -ENODEV; }
  
  LOG_ERR_RET (sensor_read (sd, 0x0001, &rdval) )
  vfe_dev_dbg ("sensor read id=0x%x\n", rdval);
  if (rdval != 0x61)
  { return -ENODEV; }
  
  return 0;
}

static int sensor_init (struct v4l2_subdev * sd, u32 val)
{
  int ret;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_init\n");
  
  /*Make sure it is a target sensor*/
  ret = sensor_detect (sd);
  if (ret) {
    vfe_dev_err ("chip found is not an target chip.\n");
    return ret;
  }
  
  vfe_get_standby_mode (sd, &info->stby_mode);
  
  if ( (info->stby_mode == HW_STBY || info->stby_mode == SW_STBY) \
       && info->init_first_flag == 0) {
    vfe_dev_print ("stby_mode and init_first_flag = 0\n");
    return 0;
  }
  
  info->focus_status = 0;
  info->low_speed = 0;
  info->width = QSXGA_WIDTH;
  info->height = QSXGA_HEIGHT;
  info->hflip = 0;
  info->vflip = 0;
  info->gain = 0;
  
  info->tpf.numerator = 1;
  info->tpf.denominator = 15;    /* 30fps */
  
  ret = sensor_write_array (sd, sensor_default_regs, ARRAY_SIZE (sensor_default_regs) );
  if (ret < 0) {
    vfe_dev_err ("write sensor_default_regs error\n");
    return ret;
  }
  
  if (info->stby_mode == 0)
  { info->init_first_flag = 0; }
  
  info->preview_first_flag = 1;
  
  return 0;
}

static long sensor_ioctl (struct v4l2_subdev * sd, unsigned int cmd, void * arg)
{
  int ret = 0;
  struct sensor_info * info = to_state (sd);
  vfe_dev_dbg ("cmd=%d\n", cmd);
  vfe_dev_dbg ("arg=%0x\n", arg);
  switch (cmd) {
  case GET_CURRENT_WIN_CFG:
    if (info->current_wins != NULL)
    {
      memcpy ( arg,
               info->current_wins,
               sizeof (struct sensor_win_size) );
      ret = 0;
    }
    else
    {
      vfe_dev_err ("empty wins!\n");
      ret = -1;
    }
    break;
  default:
    return -EINVAL;
  }
  return ret;
}


/*
 * Store information about the video data format.
 */
static struct sensor_format_struct {
  __u8 * desc;
  enum v4l2_mbus_pixelcode mbus_code;
  struct regval_list * regs;
  int regs_size;
  int bpp;   /* Bytes per pixel */
} sensor_formats[] = {
  {
    .desc       = "Raw RGB Bayer",
    .mbus_code  = V4L2_MBUS_FMT_SGRBG12_12X1,
    .regs       = sensor_fmt_raw,
    .regs_size  = ARRAY_SIZE (sensor_fmt_raw),
    .bpp        = 1
  },
};
#define N_FMTS ARRAY_SIZE(sensor_formats)



/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */


static struct sensor_win_size sensor_win_sizes[] = {
  /* 8M: 3280*2464 */
  {
    .width      = 3280,
    .height     = 2464,
    .hoffset    = 0,
    .voffset    = 0,
    .hts        = 3454,
    .vts        = 2510,
    .pclk       = 260 * 1000 * 1000,
    .mipi_bps   = 780 * 1000 * 1000,
    .fps_fixed  = 1,
    .bin_factor = 1,
    .intg_min   = 1 << 4,
    .intg_max   = 2510 << 4,
    .gain_min   = 1 << 4,
    .gain_max   = 8 << 4,
    .regs       = sensor_8M_regs,
    .regs_size  = ARRAY_SIZE (sensor_8M_regs),
    .set_size   = NULL,
  },
  /* 1080p crop */
  {
    .width      = 1920,
    .height     = 1080,
    .hoffset    = 0,
    .voffset    = 0,
    .hts        = 3500,
    .vts        = 1235,
    .pclk       = 260 * 1000 * 1000,
    .mipi_bps   = 780 * 1000 * 1000,
    .fps_fixed  = 1,
    .bin_factor = 1,
    .intg_min   = 1 << 4,
    .intg_max   = 1235 << 4,
    .gain_min   = 1 << 4,
    .gain_max   = 8 << 4,
    .regs       = sensor_1080p_crop_regs,
    .regs_size  = ARRAY_SIZE (sensor_1080p_crop_regs),
    .set_size   = NULL,
  },
  /* 1080p */
  {
    .width      = 1920,
    .height     = 1080,
    .hoffset    = 0,
    .voffset    = 0,
    .hts        = 3454,
    .vts        = 2510,
    .pclk       = 260 * 1000 * 1000,
    .mipi_bps   = 780 * 1000 * 1000,
    .fps_fixed  = 1,
    .bin_factor = 1,
    .intg_min   = 1 << 4,
    .intg_max   = 2510 << 4,
    .gain_min   = 1 << 4,
    .gain_max   = 8 << 4,
    .regs       = sensor_1080p_regs,
    .regs_size  = ARRAY_SIZE (sensor_1080p_regs),
    .set_size   = NULL,
  },
  
};

#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))

static int sensor_enum_fmt (struct v4l2_subdev * sd, unsigned index,
                            enum v4l2_mbus_pixelcode * code)
{
  if (index >= N_FMTS)
  { return -EINVAL; }
  
  *code = sensor_formats[index].mbus_code;
  return 0;
}


static int sensor_try_fmt_internal (struct v4l2_subdev * sd,
                                    struct v4l2_mbus_framefmt * fmt,
                                    struct sensor_format_struct ** ret_fmt,
                                    struct sensor_win_size ** ret_wsize)
{
  int index;
  struct sensor_win_size * wsize;
  struct sensor_info * info = to_state (sd);
  
  for (index = 0; index < N_FMTS; index++)
    if (sensor_formats[index].mbus_code == fmt->code)
    { break; }
    
  if (index >= N_FMTS)
  { return -EINVAL; }
  
  if (ret_fmt != NULL)
  { *ret_fmt = sensor_formats + index; }
  
  /*
   * Fields: the sensor devices claim to be progressive.
   */
  
  fmt->field = V4L2_FIELD_NONE;
  
  /*
   * Round requested image size down to the nearest
   * we support, but not below the smallest.
   */
  for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
       wsize++)
    if (fmt->width >= wsize->width && fmt->height >= wsize->height)
    { break; }
    
  if (wsize >= sensor_win_sizes + N_WIN_SIZES)
  { wsize--; }   /* Take the smallest one */
  if (ret_wsize != NULL)
  { *ret_wsize = wsize; }
  
  info->current_wins = wsize;
  
  /*
   * Note the size we'll actually handle.
   */
  fmt->width = wsize->width;
  fmt->height = wsize->height;
  
  return 0;
}

static int sensor_try_fmt (struct v4l2_subdev * sd,
                           struct v4l2_mbus_framefmt * fmt)
{
  return sensor_try_fmt_internal (sd, fmt, NULL, NULL);
}

static int sensor_g_mbus_config (struct v4l2_subdev * sd,
                                 struct v4l2_mbus_config * cfg)
{
  cfg->type = V4L2_MBUS_CSI2;
  cfg->flags = 0 | V4L2_MBUS_CSI2_4_LANE | V4L2_MBUS_CSI2_CHANNEL_0;
  
  return 0;
}


/*
 * Set a format.
 */
static int sensor_s_fmt (struct v4l2_subdev * sd,
                         struct v4l2_mbus_framefmt * fmt)
{
  int ret;
  struct sensor_format_struct * sensor_fmt;
  struct sensor_win_size * wsize;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_s_fmt\n");
  
  
  ret = sensor_try_fmt_internal (sd, fmt, &sensor_fmt, &wsize);
  if (ret)
  { return ret; }
  
  if (info->capture_mode == V4L2_MODE_VIDEO)
  {
  }
  else
    if (info->capture_mode == V4L2_MODE_IMAGE)
    {
      
    }
    
  sensor_write_array (sd, sensor_fmt->regs, sensor_fmt->regs_size);
  
  ret = 0;
  printk ("wsize->regs=0x%x\n", wsize->regs);
  if (wsize->regs)
    LOG_ERR_RET (sensor_write_array (sd, wsize->regs, wsize->regs_size) )
    
    if (wsize->set_size)
      LOG_ERR_RET (wsize->set_size (sd) )
      
      info->fmt = sensor_fmt;
  info->width = wsize->width;
  info->height = wsize->height;
  
  vfe_dev_print ("s_fmt set width = %d, height = %d\n", wsize->width, wsize->height);
  
  if (info->capture_mode == V4L2_MODE_VIDEO)
  {
    
  }
  else {
    
  }
  
  printk ("s_fmt end\n");
  return 0;
}

/*
 * Implement G/S_PARM.  There is a "high quality" mode we could try
 * to do someday; for now, we just do the frame rate tweak.
 */
static int sensor_g_parm (struct v4l2_subdev * sd, struct v4l2_streamparm * parms)
{
  struct v4l2_captureparm * cp = &parms->parm.capture;
  struct sensor_info * info = to_state (sd);
  
  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
  { return -EINVAL; }
  
  memset (cp, 0, sizeof (struct v4l2_captureparm) );
  cp->capability = V4L2_CAP_TIMEPERFRAME;
  cp->capturemode = info->capture_mode;
  
  return 0;
}

static int sensor_s_parm (struct v4l2_subdev * sd, struct v4l2_streamparm * parms)
{
  struct v4l2_captureparm * cp = &parms->parm.capture;
  struct sensor_info * info = to_state (sd);
  
  vfe_dev_dbg ("sensor_s_parm\n");
  
  if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
  { return -EINVAL; }
  
  if (info->tpf.numerator == 0)
  { return -EINVAL; }
  
  info->capture_mode = cp->capturemode;
  
  return 0;
}


static int sensor_queryctrl (struct v4l2_subdev * sd,
                             struct v4l2_queryctrl * qc)
{
  /* Fill in min, max, step and default value for these controls. */
  /* see include/linux/videodev2.h for details */
  
  switch (qc->id) {
  case V4L2_CID_GAIN:
    return v4l2_ctrl_query_fill (qc, 1 * 16, 8 * 16, 1, 16);
  case V4L2_CID_EXPOSURE:
    return v4l2_ctrl_query_fill (qc, 0, 65535 * 16, 1, 0);
  }
  return -EINVAL;
}

static int sensor_g_ctrl (struct v4l2_subdev * sd, struct v4l2_control * ctrl)
{
  switch (ctrl->id) {
  case V4L2_CID_GAIN:
    return sensor_g_gain (sd, &ctrl->value);
  case V4L2_CID_EXPOSURE:
    return sensor_g_exp (sd, &ctrl->value);
  }
  return -EINVAL;
}

static int sensor_s_ctrl (struct v4l2_subdev * sd, struct v4l2_control * ctrl)
{
  struct v4l2_queryctrl qc;
  int ret;
  
  qc.id = ctrl->id;
  ret = sensor_queryctrl (sd, &qc);
  if (ret < 0) {
    return ret;
  }
  
  if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
    return -ERANGE;
  }
  
  switch (ctrl->id) {
  case V4L2_CID_GAIN:
    return sensor_s_gain (sd, ctrl->value);
  case V4L2_CID_EXPOSURE:
    return sensor_s_exp (sd, ctrl->value);
  }
  return -EINVAL;
}


static int sensor_g_chip_ident (struct v4l2_subdev * sd,
                                struct v4l2_dbg_chip_ident * chip)
{
  struct i2c_client * client = v4l2_get_subdevdata (sd);
  
  return v4l2_chip_ident_i2c_client (client, chip, V4L2_IDENT_SENSOR, 0);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
  .g_chip_ident = sensor_g_chip_ident,
  .g_ctrl = sensor_g_ctrl,
  .s_ctrl = sensor_s_ctrl,
  .queryctrl = sensor_queryctrl,
  .reset = sensor_reset,
  .init = sensor_init,
  .s_power = sensor_power,
  .ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
  .enum_mbus_fmt = sensor_enum_fmt,
  .try_mbus_fmt = sensor_try_fmt,
  .s_mbus_fmt = sensor_s_fmt,
  .s_parm = sensor_s_parm,
  .g_parm = sensor_g_parm,
  .g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_ops sensor_ops = {
  .core = &sensor_core_ops,
  .video = &sensor_video_ops,
};

/* ----------------------------------------------------------------------- */
static struct cci_driver cci_drv = {
  .name = SENSOR_NAME,
};

static int sensor_probe (struct i2c_client * client,
                         const struct i2c_device_id * id)
{
  struct v4l2_subdev * sd;
  struct sensor_info * info;

  info = kzalloc (sizeof (struct sensor_info), GFP_KERNEL);
  if (info == NULL)
  { return -ENOMEM; }
  sd = &info->sd;
  glb_sd = sd;
  cci_dev_probe_helper (sd, client, &sensor_ops, &cci_drv);
  
  info->fmt = &sensor_formats[0];
  info->af_first_flag = 1;
  info->init_first_flag = 1;
  
  return 0;
}

static int sensor_remove (struct i2c_client * client)
{
  struct v4l2_subdev * sd;
  sd = cci_dev_remove_helper (client, &cci_drv);
  kfree (to_state (sd) );
  return 0;
}

static const struct i2c_device_id sensor_id[] = {
  { SENSOR_NAME, 0 },
  { }
};
MODULE_DEVICE_TABLE (i2c, sensor_id);


static struct i2c_driver sensor_driver = {
  .driver = {
    .owner = THIS_MODULE,
    .name = SENSOR_NAME,
  },
  .probe = sensor_probe,
  .remove = sensor_remove,
  .id_table = sensor_id,
};
static __init int init_sensor (void)
{
  return cci_dev_init_helper (&sensor_driver);
}

static __exit void exit_sensor (void)
{
  cci_dev_exit_helper (&sensor_driver);
}

module_init (init_sensor);
module_exit (exit_sensor);

